# sleigh specification file for HP NMOS-II
#
# Copyright (c) 2023 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#


#--------------------------------------------------------------------------
# Spaces

define endian=big;
define alignment=2;
define space ram      type=ram_space      size=2  wordsize=2 default;
define space register type=register_space size=2;

#--------------------------------------------------------------------------
# Registers
                                   #0 2 4 6 8  a  c  e  10 12 14 16    18    1a   1c 1e 20  22 24
define register offset=0x0 size=2 [ A B P R R4 R5 R6 R7 IV PA W  DMAPA DMAMA DMAC C  D  AR2 SE X R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 R31];

define register offset=0x40 size=2  [ loc ];


# condition flags
define register offset=0x50 size=1   [ DC_F HLT_F FLG_F STS_F ];

#--------------------------------------------------------------------------
# Macros

macro compare_and_skip_if_not_equal(register, memory) {
  if (register == memory) goto <continue>;
  P = P + 2;
<continue>
}
#--------------------------------------------------------------------------
# Mnemonics

# -- memory reference

define token memory_reference(16)
  opcode = (0,15)
  di = (15,15)   # direct / indirect
  op_mem = (11,14)  # instruction
  page = (10,10) # base / current page
  addr = (0,9) signed  # address
;

memref: addr is addr & di=0 & page=0 { export *[ram]:2 addr; }
memref: addr^",I" is addr & di=1 & page=0  { export *:2 addr; }
memref: loc is addr & di=0 & page=1 [ loc = inst_start + addr; ] { export *[ram]:2 loc; }
memref: loc^",I" is addr & di=1 & page=1 [ loc = inst_start + addr; ] { export *:2 loc; }

:LDA memref is op_mem=0 & memref { A = memref; }
:LDB memref is op_mem=1 & memref { B = memref; }
:CPA memref is op_mem=2 & memref { compare_and_skip_if_not_equal(A, memref); }
:CPB memref is op_mem=3 & memref { compare_and_skip_if_not_equal(B, memref); }
:ADA memref is op_mem=4 & memref { A = A + memref; }
:ADB memref is op_mem=5 & memref { B = B + memref; }
:STA memref is op_mem=6 & memref { *memref = A; }
:STB memref is op_mem=7 & memref { *memref = B; }
:JSM memref is op_mem=8 & memref { R = R + 1; *R:2 = P; call memref; }
:ISZ memref is op_mem=9 & memref { }
:AND memref is op_mem=10 & memref { }
:DSZ memref is op_mem=11 & memref { }
:IOR memref is op_mem=12 & memref { }
:JMP memref is op_mem=13 & memref { goto memref; }

# -- shift / rotate

define token shift_rotate(16)
  op1215 = (12,15)  # opcode1
  op911 = (9,11)
  op68 = (6,8)
  op45 = (4,5)
  count = (0,3)
  skip = (0,5)
;

shift: count is count { export *[const]:1 count; }

:AAR shift is op1215=0xf & op911=0 & op68 = 4 & op45 = 0 & shift { }
:ABR shift is op1215=0xf & op911=4 & op68 = 4 & op45 = 0 & shift { }
:SAR shift is op1215=0xf & op911=0 & op68 = 5 & op45 = 0 & shift { }
:SBR shift is op1215=0xf & op911=4 & op68 = 5 & op45 = 0 & shift { }
:SAL shift is op1215=0xf & op911=0 & op68 = 6 & op45 = 0 & shift { }
:SBL shift is op1215=0xf & op911=4 & op68 = 6 & op45 = 0 & shift { }
:RAR shift is op1215=0xf & op911=0 & op68 = 7 & op45 = 0 & shift { }
:RBR shift is op1215=0xf & op911=4 & op68 = 7 & op45 = 0 & shift { }

# -- skip

skip_field: skip is skip { export *[const]:1 skip; }

:RZA skip_field is op1215=7 & op911=2 & op68=0 & skip_field { }
:RZB skip_field is op1215=7 & op911=6 & op68=0 & skip_field { }
:SZA skip_field is op1215=7 & op911=2 & op68=4 & skip_field { }
:SZB skip_field is op1215=7 & op911=6 & op68=4 & skip_field { }
:RIA skip_field is op1215=7 & op911=2 & op68=1 & skip_field { }
:RIB skip_field is op1215=7 & op911=6 & op68=1 & skip_field { }
:SIA skip_field is op1215=7 & op911=2 & op68=5 & skip_field { }
:SIB skip_field is op1215=7 & op911=6 & op68=5 & skip_field { }
:SFS skip_field is op1215=7 & op911=2 & op68=2 & skip_field { }
:SFC skip_field is op1215=7 & op911=2 & op68=6 & skip_field { }
:SSS skip_field is op1215=7 & op911=6 & op68=2 & skip_field { }
:SSC skip_field is op1215=7 & op911=6 & op68=6 & skip_field { }
:SDS skip_field is op1215=7 & op911=2 & op68=3 & skip_field { }
:SDC skip_field is op1215=7 & op911=2 & op68=7 & skip_field { }
:SHS skip_field is op1215=7 & op911=6 & op68=3 & skip_field { }
:SHC skip_field is op1215=7 & op911=6 & op68=7 & skip_field { }

# -- return

:RET skip_field is op1215=0xf & op911=0 & op68=2 & skip_field { }
:RET "pop,"^skip_field is op1215=0xf & op911=0 & op68=3 & skip_field { }

# -- complement

:CMA is opcode=0xf060 { A = ~A; }
:CMB is opcode=0xf860 { B = ~B; }
:TCA is opcode=0xf020 { A = -A; }
:TCB is opcode=0xf820 { B = -B; }

# -- alter

define token alter(16)
  op815 = (8,15)
  hold = (7,7)
  clear_set = (6,6)
  alter_skip = (0,5)
;

:RLA alter_skip is op815=0x77 & alter_skip { }
:RLB alter_skip is op815=0x7f & alter_skip { }
:SLA alter_skip is op815=0x76 & alter_skip { }
:SLB alter_skip is op815=0x7e & alter_skip { }
:SAP alter_skip is op815=0xf4 & alter_skip { }
:SBP alter_skip is op815=0xfc & alter_skip { }
:SAM alter_skip is op815=0xf5 & alter_skip { }
:SBM alter_skip is op815=0xfd & alter_skip { }
:SOC alter_skip is op815=0xf6 & alter_skip { }
:SOS alter_skip is op815=0xf7 & alter_skip { }
:SEC alter_skip is op815=0xfe & alter_skip { }
:SES alter_skip is op815=0xff & alter_skip { }

# -- execute

define token execute(16)
  exe_d_i = (15,15)
  exe_opcode = (5,14)
  regaddr = (0,4)
;

                             # 0 1 2 3 4  5  6  7  8  9  10 11    12    13   14 15 16  17 18 19  20  21  22  23  24  25  26  27  28  29  30  31
attach variables [ regaddr ] [ A B P R R4 R5 R6 R7 IV PA W  DMAPA DMAMA DMAC C  D  AR2 SE X  R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 R31];

:EXE_D regaddr is exe_d_i=0 & exe_opcode=0x380 & regaddr { }
:EXE_I regaddr is exe_d_i=1 & exe_opcode=0x380 & regaddr { }

# -- 16-bit IOC only

:SDO is opcode=0x7100 { }
:SDI is opcode=0x7108 { }
:DBL is opcode=0x7140 { }
:CBL is opcode=0x7148 { }
:DBU is opcode=0x7150 { }
:CBU is opcode=0x7158 { }

# -- stack

define token stack(16)
  stack_opcode = (8,15)
  stack_d_i = (7,7)
  stack_opcode2 = (3,6)
  stack_register = (0,2)
;

:PWC_inc stack_register is stack_opcode=0x71 & stack_d_i=0 & stack_opcode2=0xc & stack_register { }
:PWC_dec stack_register is stack_opcode=0x71 & stack_d_i=1 & stack_opcode2=0xc & stack_register { }
:PBC_inc stack_register is stack_opcode=0x79 & stack_d_i=0 & stack_opcode2=0xc & stack_register { }
:PBC_dec stack_register is stack_opcode=0x79 & stack_d_i=1 & stack_opcode2=0xc & stack_register { }
:PWD_inc stack_register is stack_opcode=0x71 & stack_d_i=0 & stack_opcode2=0xd & stack_register { }
:PWD_dec stack_register is stack_opcode=0x71 & stack_d_i=1 & stack_opcode2=0xd & stack_register { }
:PBD_inc stack_register is stack_opcode=0x79 & stack_d_i=0 & stack_opcode2=0xd & stack_register { }
:PBD_dec stack_register is stack_opcode=0x79 & stack_d_i=1 & stack_opcode2=0xd & stack_register { }
:WWC_inc stack_register is stack_opcode=0x71 & stack_d_i=0 & stack_opcode2=0xe & stack_register { }
:WWC_dec stack_register is stack_opcode=0x71 & stack_d_i=1 & stack_opcode2=0xe & stack_register { }
:WBC_inc stack_register is stack_opcode=0x79 & stack_d_i=0 & stack_opcode2=0xe & stack_register { }
:WBC_dec stack_register is stack_opcode=0x79 & stack_d_i=1 & stack_opcode2=0xe & stack_register { }
:WWD_inc stack_register is stack_opcode=0x71 & stack_d_i=0 & stack_opcode2=0xf & stack_register { }
:WWD_dec stack_register is stack_opcode=0x71 & stack_d_i=1 & stack_opcode2=0xf & stack_register { }
:WBD_inc stack_register is stack_opcode=0x79 & stack_d_i=0 & stack_opcode2=0xf & stack_register { }
:WBD_dec stack_register is stack_opcode=0x79 & stack_d_i=1 & stack_opcode2=0xf & stack_register { }

# -- interrupt

:EIR is opcode=0xf110 { }
:DIR is opcode=0xf118 { }

# -- dma

:DMA is opcode=0x7120 { }
:PCM is opcode=0x7128 { }
:DDR is opcode=0x7138 { }

# -- four word operation

define token four_word(16)
  fw_opcode = (4,15)
  fw_words = (0,3)
;

:CLR fw_words is fw_opcode=0x738 & fw_words { }
:XFR fw_words is fw_opcode=0x730 & fw_words { }

# -- mantissa shift

:MRX is opcode=0x7b00 { }
:DRS is opcode=0x7b21 { }
:MLY is opcode=0x7b61 { }
:MRY is opcode=0x7b40 { }
:NRM is opcode=0x7340 { }

# -- arithmetic

:FXA is opcode=0x7280 { }
:MWA is opcode=0x7200 { }
:CMX is opcode=0x72c0 { }
:CMY is opcode=0x7240 { }
:FMP is opcode=0x7a00 { }
:FDV is opcode=0x7a21 { }
:MPY is opcode=0x7b8f { }
:CDC is opcode=0x73c0 { }
